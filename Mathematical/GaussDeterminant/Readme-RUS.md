# Алгоритм Гаусса для нахождения определителя
## Оглавление
- [Описание алгоритма](#описание-алгоритма)
- [Пример для матрицы 2x2](#пример-для-матрицы-2x2)
- [Особенности реализации](#особенности-реализации)
- [Сложность](#сложность)

## Описание алгоритма
Определение алгоритма по методу Гаусса происходит путём преобразования матрицы к верхнетреугольному виду с последующим перемножением элементов главной диагонали
### Шаг 0: Ввод данных
- Программа ожидает на ввод размер матрицы (n) и nxn элементов матрицы построчно
### Шаг 1: Подготовка
- **Смотрим на первый элемент первой строки** - это наш первый опорный элемент
- **Если он равен 0** - ищем строку ниже, где первый элемент не ноль, и меняем строки местами
- **Запоминаем**, что каждая перестановка строк меняет знак определителя
### Шаг 2: Прямой ход (для каждого столбца j)
- **Берём опорный элемент** - `matrix[j][j]`
- **Для всех строк i ниже опорной** (i = j+1, j+2, ..., n):
  - **Вычисляем множитель**: `multiplier = -matrix[i][j] / matrix[j][j]` 
  - **Преобразуем строку i**: для каждого столбца k от j до n:
    - `matrix[i][k] += multiplier * matrix[j][k]`
  - Таким образом, обнуляем все элементы ниже опорного
 
## Пример для матрицы 2x2

Исходная матрица:
```
[2, 1]
[1, 3]
```

### Шаг 1: 
- **Опорный элемент** = 2 (не ноль, перестановка не нужна)

### Шаг 2:
- **Множитель для строки 1**: `multiplier = -1/2`
- **Преобразуем строку 2**: 
  - `matrix[1][0] = 1 + (-1/2)*2 = 0`
  - `matrix[1][1] = 3 + (-1/2)*1 = 2.5`

Получаем:
```
[2,   1  ]
[0,   2.5]
```

### Шаг 3:
- **Определитель** = 2 × 2.5 = 5

## Особенности реализации
- **Используется `double`** для точности вычислений
- **Epsilon-сравнение** вместо точного равенства с нулём
- **Ранний выход** при обнаружении нулевого определителя

## Сложность
Прямой ход (приведение к треугольному виду): имеет временную сложность O(n³).
